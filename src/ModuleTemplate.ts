/** 
* This template file was generated by the bifrost-sdk.
* Edit the init and update functions to create business logic
for your module. 
*/ 
import { DataFrame, TModuleContext, TState } from 'bifrost-zero-common'
import { BifrostZeroModule } from 'bifrost-zero-sdk'

interface Dictionary<T> {
    [Key: string]: T;
}

// Exemplary dynamic types
const T_AMBIENT_NOISE_LEVEL = 'AMBIENT-NOISE-LEVEL' 
const T_POLITICAL_MODEL = 'POLITICAL-MODEL' 
const T_OCCUPANCY = 'OCCUPANCY'

type oStruct = {
    ids: string[],
    min: number,
    max: number
}
// Exemplary dynamic types
const T_FLOW_REVENUE = '~REVENUE' 
const T_FLOW_ENERGY = '~ENERGY' 
const T_FLOW_PEOPLE = '~PEOPLE'

const logic = { 
    noiseLevelDynamics : {} as Dictionary<string[]>,
    politicalModelDynamics : {} as Dictionary<string[]>,
    occupancyStruct : {} as Dictionary<oStruct>,
    politicalModelEnums : {},
    generateNoiseLevel : true,
    generatePoliticalModel : true,
    generateOccupancy : true,
    flowRevenueDynamics : {} as Dictionary<string[]>,
    flowEnergyDynamics : {} as Dictionary<string[]>,
    flowPeopleDynamics : {} as Dictionary<string[]>,

    initFn: (storyId: string, experimentId: string, state: TState, context: TModuleContext) => { 
        context.log.write(`Init from [${storyId}/${experimentId}]`)
        // Insert expensive setup calculations and static state query expressions here.
        // Store the instance IDs of the dynamics this module
        // provides locally for later access during the update function.
        logic.noiseLevelDynamics[experimentId] = state.dynamics.ids.filter(entry => entry.includes(T_AMBIENT_NOISE_LEVEL))
        logic.politicalModelDynamics[experimentId] = state.dynamics.ids.filter(entry => entry.includes(T_POLITICAL_MODEL))
        logic.politicalModelEnums = state.directory.dynamics.entities[T_POLITICAL_MODEL].schema.enum
        const occupancyIds = state.dynamics.ids.filter(entry => entry.includes(T_OCCUPANCY))
        const occuMinMax = state.directory.dynamics.entities[T_OCCUPANCY].schema.items
        logic.occupancyStruct[experimentId] = { ids: occupancyIds, min: occuMinMax.minimum, max: occuMinMax.maximum }
        // Store the instance IDs of the dynamics this module provides locally
        // for later access during the update function.
        logic.flowRevenueDynamics[experimentId] = state.dynamics.ids.filter(entry => entry.includes(T_FLOW_REVENUE))
        logic.flowEnergyDynamics[experimentId] = state.dynamics.ids.filter(entry => entry.includes(T_FLOW_ENERGY))
        logic.flowPeopleDynamics[experimentId] = state.dynamics.ids.filter(entry => entry.includes(T_FLOW_PEOPLE))

        return new DataFrame()
    },
    updateFn: (storyId: string, experimentId: string, startAt:number, simulationAt: number, replayAt: number, data: DataFrame, context: TModuleContext) => {
        context.log.write(`\nUpdate from [${storyId}/${experimentId}] @ ${simulationAt}`)
        const result: DataFrame = new DataFrame()
        result.setTime(simulationAt)
        // Insert your module update logic here.
        // Generate some random data values and add them as time series to the DataFrame result
        if(logic.generateNoiseLevel) {
            for (const dynamicId of logic.noiseLevelDynamics[experimentId]) {
                result.addSeries({dynamicId, values: [generators.randFloat()]})
            }
        }
        if (logic.generatePoliticalModel) {
            for (const dynamicId of logic.politicalModelDynamics[experimentId]) {
                result.addSeries({dynamicId, values:[generators.pickStr(logic.politicalModelEnums as string[])]})
            } 
        }
        if (logic.generateOccupancy) {
            const occupancyStruct = logic.occupancyStruct[experimentId]
            for (const dynamicId of occupancyStruct.ids) {
                result.addSeries({dynamicId, values: [[generators.randInt(occupancyStruct.min,occupancyStruct.max),
                                                                        generators.randInt(occupancyStruct.min,occupancyStruct.max),
                                                                        generators.randInt(occupancyStruct.min,occupancyStruct.max),
                                                                        generators.randInt(occupancyStruct.min,occupancyStruct.max)]]})
            }
        }

    // Use the subscriptions and add something to the flow dynamics
    if (!data.isEmpty()) {
        for (const seriesElement of data.series) {
            switch (seriesElement.meta.typeId) {
                case T_FLOW_REVENUE:
                    let rvalue = seriesElement.values[0] as number
                    if (simulationAt % 5 === 0) {
                        rvalue = generators.clamp(generators.inc(rvalue, 0.1), [-1, 1])
                    }
                    result.addSeries({ dynamicId: seriesElement.dynamicId, values: [rvalue] })
                    break
                case T_FLOW_ENERGY:
                    let evalue = seriesElement.values[0] as number
                    if (simulationAt % 10 === 0) {
                        evalue = generators.clamp(generators.inc(evalue, 0.1), [-1, 1])
                    }
                    result.addSeries({ dynamicId: seriesElement.dynamicId, values: [evalue] })
                    break
                case T_FLOW_PEOPLE:
                    let pvalue = seriesElement.values[0] as number
                    if (simulationAt % 15 === 0) {
                        pvalue = generators.clamp(generators.inc(pvalue, 0.1), [-1, 1])
                    }
                    result.addSeries({ dynamicId: seriesElement.dynamicId, values: [pvalue] })
                    break
                default:
                    break
            }
        }
    }
        return result
    }
}

    // Data generators.
    const generators = {
        // Helper functions
        inc: (a: number, by: number) => a + by,
        dec: (a: number, by: number) => a - by,
        clamp: (a: number, bounds: [number, number]) => Math.max(bounds[0], Math.min(a, bounds[1])),
        pickInt: (a: number[]) => a[Math.floor(Math.random() * a.length)],
        pickStr: (a: string[]) => a[Math.floor(Math.random() * a.length)],
        randFloat: (min: number = 0, max: number = 1) => Math.random() * (max - min) + min,
        randInt: (min: number = 0, max: number = 1) => Math.floor(Math.random() * (max - min) + min),
        rand01: (bias: number = 0) => Math.round(Math.random() + bias),
    }

const m = new BifrostZeroModule({
    author: 'anonymous',
    label: 'ModuleTemplate',
    about: 'ZERO Module Template',
    initCallback: logic.initFn,
    updateCallback: logic.updateFn,
    fragmentFile: './data/ModuleTemplate.Fragment.yaml',
    subscriptions: [
                    T_FLOW_REVENUE, T_FLOW_ENERGY, T_FLOW_PEOPLE
                    ],
    samplingRate:900,
    docURL: '',
    moduleURL: process.env.MODULE_URL || 'http://localhost:1809',
    bifrostURL: process.env.BIFROST_URL || 'http://localhost:9091',
    hook: [100]
})
m.start()